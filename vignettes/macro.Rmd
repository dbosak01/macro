---
title: "macro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{macro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
The **macro** package provides macro commands and a pre-processor for R programs.
The package can be useful in several ways.  Before illustrating the functionality,
let's first discuss the macro concept at a high level.

# Macro Concept

A macro language is like a meta-language for code.  The meta-language runs first,
generates the regular code, and then the regular code is executed to produce 
some sort of output. It is, at heart, a text replacement/generation system.

The SAS® macro language is commonly used in SAS programs. The R **macro** package 
was inspired by SAS. Specifically, the **macro** package aims to replicate
SAS macro with "mprint" and "mfile" options turned on.  These options generate 
a resolved code file.

# An R Macro Language

Clearly, a macro language for R will not be the same as the SAS macro language.
The SAS macro language is built into the SAS execution environment.  The SAS
pre-processor is run automatically, and the macro syntax is understood by the 
SAS syntax checker.

With R, none of the above applies.  R does not have a built-in macro language, 
does not have a built-in pre-processor, and the R syntax checker will not 
expect any sort of macro language syntax.

Therefore, to build macro-like functionality in R, we must get a little creative.

# Macro Statements

The first thing to note is that macro statements in the **macro** package are 
written as code comments.  The comments ensure that the R syntax checker will not
generate an error when parsing the macro functions. 

In SAS, macro functions are
prefixed with a percent sign (%).  In R, macro statements are therefore prefixed
with a comment symbol (#) and a percent sign (%).  A simple macro assignment
looks like this:

```{r eval=FALSE, echo=TRUE}
#%let x <- 1
```
A simple macro conditional looks like this:

```{r eval=FALSE, echo=TRUE}
#%if (&x == 1)
  print("x is one!")
#%else
  print("x is something else!")
#%end

```

Note that the above R macro syntax is not identical to the SAS syntax. The syntax
devised for the **macro** package is a blend of SAS and R syntax. 

# Differences Between SAS Macro and R Macro 

Here are some of the major difference between the SAS macro language and the 
R macro language:

  * R macro statements do not end with a semicolon (";").  They are single-line
  commands, and end with a carriage return.
  * R macro commands can be used anywhere in the program.  They are not restricted to 
  use inside macro functions.  
  * Single-quotes will not prevent macro variable resolution.  In the R macro
  language, single and double quotes operate the same.
  * All operators in the R macro language use R syntax, including the 
  comparison operator ("==").
  * R macro variables in open code must be surrounded by backticks ("`") to 
  avoid errors. Inside comments and other macro commands, they do not need
  backticks.  

# The msource() function

In the **macro** package, pre-processing of the macro code is accomplished by a special function:
`msource()`. The `msource()` function is similar to the `source()` function in R.
The `msource()` function will execute your code, just like the `source()` function.
First, however, it will execute the **macro** pre-processor.  

The steps can be summarized as follows:

  Step 1: Pre-process the code and resolve all macro language syntax.  
  Step 2: Generate a new code file with the resolved code.  
  Step 3: Execute the resolved code with the `source()` function.  

Notice that the above steps map directly to the way the SAS
macro processor works.

In addition, the R macro language is a text-replacement language, just like SAS.  Macro
variables are swapped out with real values as text replacements.  Macro conditions
are evaluated, and only the code in the TRUE macro conditions is executed. 

All of the above is handled by the `msource()` function. `msource()` is in fact the 
only user-facing function in the **macro** package.

## How to Use

To use the **macro** package, you will first write your macro-enabled R code in 
a regular ".R" code file.  You can use
RStudio® or another code editor.  The macro statements are written as special
comments, as described above.  To execute a macro-enabled program, simply
call the `msource()` function in the console and pass the program path.  That's it!  

If you are working in RStudio, the function will use the path of the currently 
active program by default. In that case, you don't need to do hardly anything!
Just call `msource()` in the console with no parameters.

## Available Functionality

The **macro** package supports the most basic functionality of a macro system.
That includes: 

1. **Macro Comments**: Like regular R comments, but are not emitted to the output file.
2. **Macro Variables**:  Allow you to assign a value to a macro variable, and use
the macro variable as a text replacement token.
3. **Macro Conditionals**: If-Then-Else logic that allows you to conditionally 
execute a chunk of code.
4. **Macro Include**: Inserts the contents of an external file into your program.
5. **Built-in Macro Functions**: A small number of macro functions
to make the system more practical.
6. **Macro Do Loops**: Copies code inside the do block for each iteration of the loop.
7. **User-Defined Macro Functions**: The ability to create a user-defined  
text-replacement function, with or without parameters.

### Macro Comments and Variables

Above we saw a simple macro variable assignment. Macro variables are defined with
the keyword `#%let` and then the variable name and value.  

We can document those macro assignments with macro comments.  Macro comments
are prefixed with `#%`.  You can type anything after the prefix.

Note that macro comments are a single line comment.  There are no multi-line 
comments in R.

Here are a few macro variable assignments with comments for different data types:

```{r eval=FALSE, echo=TRUE}
#% Assign integer value 
#%let v1 <- 1

#% Assign double value
#%let v2 <- 1.2

#% Assign character value
#%let v3 <- "Hello World!"

#% Assign date value
#%let v4 <- as.Date("2025-07-15")

#% Assign vector
#%let v5 <- c(1, 2, 3, 4, 5)

#% Assign calculated value
#%let v6 <- 2 + 2

#% Assign using another macro variable
#%let v7 <- &v6

#% Calculate using another macro variable
#%let v8 <- &v7 + 1
```
Once a macro variable is assigned, it can be used as a text replacement token
anywhere in your program. 

R macro variables begin with an ampersand ("&") 
prefix, just like SAS. Also like SAS, a trailing dot (".") suffix is optional.
The trailing dot can help separate the macro variable from surrounding text.

One difference is that, in R, the ampersand ("&") is normally not 
allowed as the first character of a variable name.  
Therefore, when macro variables appear in open code,
they must be back-quoted to avoid errors.

For example, we can use some of the above macro assignments like this:
```{r eval=FALSE, echo=TRUE}
# Resolve inside a comment
# The value of 'v1' is &v1

# Resolve in a text string
a <- "The value of 'v2' is &v2"
print(a)

# Resolve in open code
b <- `&v3`
print(b)

# Resolve in a function
c <- mean(`&v5`)
print(c)

```
If we execute the above code using `msource()`, we'll get the following result:
```
> msource()
[1] "The value of 'v2' is 1.2"
[1] "Hello World!"
[1] 3
```
And the generated code would look like this:
```{r eval=FALSE, echo=TRUE}
# Resolve inside a comment
# The value of 'v1' is 1

# Resolve in a text string
a <- "The value of 'v2' is 1.2"
print(a)

# Resolve in open code
b <- "Hello World!"
print(b)

# Resolve in a function
c <- mean(c(1, 2, 3, 4, 5))
print(c)

```
Notice in the above generated code that the macro variables '&v3' and '&v5' were
replaced exactly as they were assigned.  All macro variable resolution is 
text replacement.

### Simple Macro Conditionals

Macro conditionals allows you to conditionally execute a chunk of code.  If
a macro condition is TRUE, the code inside that condition will be output
to the generated code file and executed.  Otherwise, the code will not be
emitted. This feature makes the generated code file more compact.

Here are some examples of simple macro conditions:
```{r eval=FALSE, echo=TRUE}
#% Assign integer value 
#%let x = 1

#%if (&x == 1)
  # X is one
  print("Inside the first condition")
#%elseif (&x == 2)
  # X is two
  print("Inside the second condition")
#%else 
  # X is something else
  print("Inside the else.")
#%end

```
When executed with `msource()`, the above code will generate the result 
`"Inside the first condition"`.  If you pass a file name to the `file_out`
parameter of the `msource()` function, a code file will be generated.  That
code file will contain the following content:
```{r eval=FALSE, echo=TRUE}
  # X is one
  print("Inside the first condition")

```
Notice that all spacing and comments from inside the condition are preserved.
Also notice that all macro code and code from inside other conditions has 
been removed. Only the code inside the TRUE condition has been emitted.

### Nested Macro Conditionals

Macro conditionals can also be nested. Here is an 
example that illustrates such conditionals:

```{r eval=FALSE, echo=TRUE}
#% Assign integers
#%let x = 1
#%let y = 2

#%if (&x. == 1)

  #%if (&y. == 1)

    print("X is one and Y is 1")

  #%else

    print("X is one and Y is &y.")

  #%end

#%elseif (&x. == 2)

    #%if (&y. == 1)

    print("X is two and Y is 1")

    #%else

    print("X is two and Y is &y.")

    #%end

#%else

  #%if (&y. == 1)

    print("X is &x. and Y is 1")

  #%else

    print("X is &x. and Y is &y.")

  #%end

#%end

```
The result of the above code will be "X is one and Y is 2", and the output
file will look like this:
```{r eval=FALSE, echo=TRUE}

    print("X is one and Y is 2")


```
In this way, many levels of macro logic can be boiled down to a few lines of 
generated code.

### Macro Include

There is no equivalent in Base R for a SAS macro include.  The R `source()` function
executes an external code file.  But it does not "include" or "insert" the
code into the calling program.  Therefore, the macro include from the 
**macro** package brings a useful feature to R.

A macro include from the **macro** package looks like this:
```{r eval=FALSE, echo=TRUE}
#%include 'c:/myfolder/myprogram.R'

```
Upon execution by `msource()`, the contents of "myprogram.R" will be extracted
from the file and copied into the calling program as text.  The calling program
will then be scanned for macro commands that may have existed in "myprogram.R".
The result will be a fully integrated program with all macro commands resolved.

### Macro Functions

There are a some built-in macro functions that are considered necessary for proper
operation of the system.  The essential functions are `%sysfunc()`, 
`%symexist()`, and `%symput()`.

### Evaluating and Formatting Expressions: %sysfunc()

The `%sysfunc()` macro function allows you to evaluate an R expression as
part of a macro command.  The expression can contain any valid R function
or operator.  Observe:

```{r eval=FALSE, echo=TRUE}

#% Assign integer vector
#%let a = c(2, 5, 8, 9)

#% Sum vector without %sysfunc
#%let b = sum(&a) / 1.3

#% Sum vector with %sysfunc
#%let c = %sysfunc(sum(&a) / 1.3)

#% Format expression with %sysfunc
#%let d = %sysfunc(sum(&a) / 1.3, %.2f)

# Text replacement
w <- `&a`

# Expression replacement
x <- `&b`

# Evaluated with %sysfunc()
y <- `&c`

# Formatted with %sysfunc()
z <- `&d`


```
Here is the above code after pre-processing:
```{r eval=FALSE, echo=TRUE}

# Text replacement
w <- c(2, 5, 8, 9)

# Expression replacement
x <- sum(c(2, 5, 8, 9)) / 1.3

# Evaluated with %sysfunc()
y <- 18.4615384615385

# Formatted with %sysfunc()
z <- 18.46

```
Notice how the macro values resolve differently depending on whether and how
`%sysfunc()` is used.

### Checking For Macro Variables: %symexist()

The `%symexist()` macro function is used to determine whether or not 
a macro variable exists.  You will pass the name of the macro variable
without quotes and without the ampersand ("&") prefix or the dot (".") suffix.  

Here is a very simple example:

```{r eval=FALSE, echo=TRUE}

#%let a = 1

#%if (%symexist(a))

  print("Macro variable 'a' exists!")
  print("Here is the value: &a")

#%else

  print("Macro variable 'a' does not exist!")

#%end

#%if (%symexist(b))

  print("Macro variable 'b' exists!")
  print("Here is the value: &b")

#%else

  print("Macro variable 'b' does not exist!")

#%end

```
And the resulting code looks like this:
```{r eval=FALSE, echo=TRUE}

  print("Macro variable 'a' exists!")
  print("Here is the value: 1")

  print("Macro variable 'b' does not exist!")

```

### Assigning Macro Variables from Execution Environment: %symput()

The `%symput()` function allows you examine values in the runtime environment
during pre-processing.  Notice below that you can assign macro variable values
based on regular R variables and expressions:
```{r eval=FALSE, echo=TRUE}
# Assign vector
v1 <- c("one", "two", "three")

#% Get length of vector
#%let x <- %symput(length(v1))

#% Get vector values
#%let y <- %symput(v1)

# Assign length with macro variable
a <- `&x`

# Assign vector values with macro variable
b <- `&y`

```
The generated code looks like this:
```{r eval=FALSE, echo=TRUE}
# Assign vector
v1 <- c("one", "two", "three")

# Assign length with macro variable
a <- 3

# Assign vector values with macro variable
b <- c('one', 'two', 'three')
```
This feature gives you the capability to make decisions in pre-processing
based on what is happening during execution.

### Macro Do Loops

Macro do loops can be used to easily copy a section of code multiple times.
Here is a modified version of the above `%symput()` example that demonstrates
a macro loop:
```{r eval=FALSE, echo=TRUE}
# Assign vector
v1 <- c("one", "two", "three")

#% Get length of vector
#%let x <- %symput(length(v1))

#% Get vector values
#%let y <- %symput(v1)

# Print each value of vector &y.
#%do idx = 1 %to &x.
print("Vector value %sysfunc(&y[&idx])")
#%end
```
The above macro will produce the following console output:
```
> msource()
[1] "Vector value one"
[1] "Vector value two"
[1] "Vector value three"
```
And here is the generated code:
```{r eval=FALSE, echo=TRUE}
# Assign vector
v1 <- c("one", "two", "three")

# Print each value of vector c('one', 'two', 'three')
print("Vector value one")
print("Vector value two")
print("Vector value three")
```
Note that you can have any number of statements inside the do loop. This 
macro feature is useful when you are performing repetitive operations, want
to avoid copying the code, but still want a resolved and transparent output file.

### User-defined Macro Functions

User-defined macro functions allows you to wrap up a set up statements,
assign a name to it, and call these functions as needed. Calling the function
will insert the contents of the function into the generated file. It is 
important to note the difference between a regular R function and an R
macro function: an R macro function is still a text replacement/insertion.

Here is an illustrative example:
```{r eval=FALSE, echo=TRUE}
#% Define macro function
#%macro do_analysis(data, varname)
# Analysis for "&varname"
mean_&varname <- mean(`&data`[["&varname"]])
min_&varname <- min(`&data`[["&varname"]])
max_&varname <- max(`&data`[["&varname"]])
anal_&varname <- data.frame("Variable" = "&varname",
                            "Mean" = mean_&varname,
                            "Min"  = min_&varname,
                            "Max"  = max_&varname)
#%mend

#%do_analysis(mtcars, mpg)
#%do_analysis(mtcars, cyl)
#%do_analysis(mtcars, disp)

# Combine analysis blocks
final <- rbind(anal_mpg, anal_cyl, anal_disp)

# Print result
print(final)

```
Here is the generated code.  Notice that the code inside the macro function
is repeated for every call:
```{r eval=FALSE, echo=TRUE}

# Analysis for "mpg"
mean_mpg <- mean(mtcars[["mpg"]])
min_mpg <- min(mtcars[["mpg"]])
max_mpg <- max(mtcars[["mpg"]])
anal_mpg <- data.frame("Variable" = "mpg",
                            "Mean" = mean_mpg,
                            "Min"  = min_mpg,
                            "Max"  = max_mpg)
# Analysis for "cyl"
mean_cyl <- mean(mtcars[["cyl"]])
min_cyl <- min(mtcars[["cyl"]])
max_cyl <- max(mtcars[["cyl"]])
anal_cyl <- data.frame("Variable" = "cyl",
                            "Mean" = mean_cyl,
                            "Min"  = min_cyl,
                            "Max"  = max_cyl)
# Analysis for "disp"
mean_disp <- mean(mtcars[["disp"]])
min_disp <- min(mtcars[["disp"]])
max_disp <- max(mtcars[["disp"]])
anal_disp <- data.frame("Variable" = "disp",
                            "Mean" = mean_disp,
                            "Min"  = min_disp,
                            "Max"  = max_disp)

# Combine analysis blocks
final <- rbind(anal_mpg, anal_cyl, anal_disp)

# Print result
print(final)

```
The result of the above code is a data frame that contains analysis for
all three variables.  The console output looks like this:

```
> msource()
  Variable      Mean  Min   Max
1      mpg  20.09062 10.4  33.9
2      cyl   6.18750  4.0   8.0
3     disp 230.72188 71.1 472.0
```
Using combinations of macro functions, macro do loops, and macro conditions, 
you can create very dynamic, flexible, and useful programs. 


# Next Steps

Here are some more articles for further exploration of the **macro** package:

- [Macro Language Glossary](macro-language.html) 
- [Debugging](macro-debug.html)
- [Example 1: Listing](macro-example1.html)
- [Example 2: Another Listing](macro-example2.html)
- [Example 3: Table](macro-example3.html)
- [Generalized vs. Generated](macro-generated.html)
- [Disclaimer](macro-disclaimer.html)
- [Frequently Asked Questions](macro-faq.html)
