---
title: "macro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{macro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
The **macro** package provides macro commands and a pre-processor for R programs.
The package can be useful in several ways.  Before illustrating the functionality,
Let's first discuss the macro concept at a high level.

# Macro Concept

A macro language is like a meta-language for code.  The meta-language runs first,
generates the regular code, and then the regular code is executed to produce 
some sort of output.

The SASÂ® macro language is commonly used in SAS programs. The R **macro** package 
was inspired by SAS.

# An R Macro Language

Clearly, a macro language for R will not be the same as the SAS macro language.
The SAS macro language is built into the SAS execution environment.  The SAS
pre-processor is run automatically, and the macro syntax is understood by the 
SAS syntax checker.

With R, none of the above applies.  R does not have a built-in macro language, 
does not have a built-in pre-processor, and the R syntax checker will not 
expect any sort of macro language syntax.

Therefore, to build a macro-like functionality in R, we must get a little creative.

# Macro Statements

The first thing to note is that macro statements in the **macro** package are 
written as code comments.  The comments ensure that the R syntax checker will not
generate an error when parsing the macro functions. 

In SAS, macro functions are
prefixed with a percent sign (%).  In R, macro statements are therefore prefixed
with a comment symbol (#) and a percent sign (%).  A simple macro assignment
looks like this:

```{r eval=FALSE, echo=TRUE}
#%let x = 1
```
A simple macro conditional looks like this:

```{r eval=FALSE, echo=TRUE}
#%if (x. == 1)
  print("x is one!")
#%else
  print("x is something else!")
#%end

```

Note that the above R macro syntax is not identical to the SAS syntax. The syntax
is a blend of SAS and R syntax, all inside a macro comment.

# The msource() function

In the **macro** package, pre-processing of the macro code is accomplished by a special function:
`msource()`. The `msource()` function is similar to the `source()` function in R.
The `msource()` function will execute your code, just like the `source()` function.
First, however, it will execute the **macro** pre-processor.  

The steps can be summarized as follows:

Step 1: Pre-process the code and resolve all macro language syntax.  
Step 2: Generate a new code file with the resolved code.
Step 3: Execute the resolved code with the `source()` function.

Notice that the above steps map directly to the way the SAS
macro processor works.

In addition, the R macro language is a text-replacement language, just like SAS.  Macro
variables are swapped out with real values as text replacements.  Macro conditions
are evaluated, and only the code in the TRUE macro conditions is executed. 

All of the above is handled by the `msource()` function. `msource()` is in fact the 
only user-facing function in the **macro** package.

## How to Use

You will write your macro-enabled R code in a regular .R code file.  You can use
RStudio or another code editor.  The macro statements are written as special
comments, as described above.  To execute a macro-enabled program, simply
call the `msource()` function in the console and pass the program path.  That's it!  

If you are working in RStudio, the function will use the path of the currently 
active program by default. In that case, you don't need to do hardly anything!
Just call `msource()` in the console with no parameters.

## Available Functionality

The **macro** package supports the most basic functionality of a macro system.
That includes: 

1. Macro Comments: Like regular R comments, but are not emitted to the output file.
2. Macro Variables:  Allow you to assign a value to a macro variable, and use
the macro variable as a text replacement token.
3. Macro Conditionals: If-Then-Else logic that allows you to conditionally 
execute a chunk of code.
4. System Function: The system function allows you to execute R functions
and operators as part of a macro statement.
5. Macro Include: Inserts the contents of an external file into your program.

### Macro Comments and Variables

Above we saw a simple macro variable assignment. Macro variables are defined with
the keyword `#%let` and then the variable name and value.  

We can document those macro assignments with macro comments.  Macro comments
are prefixed with `#%`.  You can type anything after the prefix.
These comments are not emitted to the generated file.  

Note that macro comments are a single line comment.  There are no multi-line 
comments in R.

Here are a few macro variable assignments with comments for different data types:

```{r eval=FALSE, echo=TRUE}
#% Assign integer value 
#%let v1 = 1

#% Assign double value
#%let v2 = 1.2

#% Assign character value
#%let v3 = "Hello World!"

#% Assign date value
#%let v4 = as.Date("2025-07-15")

#% Assign vector
#%let v5 = c(1, 2, 3, 4, 5)

#% Assign calculated value
#%let v6 = 2 + 2

#% Assign using another macro variable
#%let v7 = v6.

#% Calculate using another macro variable
#%let v8 = v7. + 1
```
Once a macro variable is assigned, it can be used as a text replacement token
anywhere in your program. 

Note that R macro variables have no ampersand ("&") 
prefix.  The reason is that R does not allow special characters in variable names.
Therefore, R macro variables are identified simply by a dot (".") suffix.

For example, we can use some of the above macro assignments like this:
```{r eval=FALSE, echo=TRUE}
# Print inside loop
for (idx in seq(1, v6.)) {
  
  print(v3.)
}

```
If we execute the above code using `msource()`, we'll get the following result:
```
> msource()
[1] "Hello World!"
[1] "Hello World!"
[1] "Hello World!"
[1] "Hello World!"
```
And the generated code would look like this:
```{r eval=FALSE, echo=TRUE}
# Print inside loop
for (idx in seq(1, 2 + 2)) {

  print("Hello World!")
}
```
Notice in the above generated code that the macro variables `v3.` and `v6.` were
replaced exactly as they were assigned.  Macro variable expressions are not resolved
unless explicitly evaluated.  

### Simple Macro Conditionals

Macro conditionals allows you to conditionally execute a chunk of code.  If
a macro condition is TRUE, the code inside that condition will be output
to the generated code file and executed.  Otherwise, the code will not be
emitted. This feature makes the generated code file more compact.

Here are some examples of simple macro conditions:
```{r eval=FALSE, echo=TRUE}
#% Assign integer value 
#%let x = 1

#%if (x. == 1)
  # X is one
  print("Inside the first condition")
#%elseif (x. == 2)
  # X is two
  print("Inside the second condition")
#%else 
  # X is something else
  print("Inside the else.")
#%end

```
When executed with `msource()`, the above code will generate the result 
`"Inside the first condition"`.  If you pass a file name to the `file_out`
parameter of the `msource()` function, a code file will be generated.  That
code fill will contain the following content:
```{r eval=FALSE, echo=TRUE}
  # X is one
  print("Inside the first condition")

```
Notice that all spacing and comments from inside the condition are preserved.
Also notice that all macro code and code from inside other conditions has 
been removed.  This feature allows you to generate efficient and readable 
code files with minimal effort.

### Nested Macro Conditionals

Macro conditionals can also be nested. Here is an 
example that illustrates such conditionals:

```{r eval=FALSE, echo=TRUE}
#% Assign integers
#%let x = 1
#%let y = 2

#%if (x. == 1)

  #%if (y. == 1)

    print("X is one and Y is 1")

  #%else

    print("X is one and Y is y.")

  #%end

#%elseif (x. == 2)

    #%if (y. == 1)

    print("X is two and Y is 1")

    #%else

    print("X is two and Y is y.")

    #%end

#%else

  #%if (y. == 1)

    print("X is x. and Y is 1")

  #%else

    print("X is x. and Y is y.")

  #%end

#%end

```
The result of the above code will be "X is one and Y is 2", and the output
file will look like this:
```{r eval=FALSE, echo=TRUE}

    print("X is one and Y is 2")


```

### System Function

Not sure what to do with this?

### Macro Include

There is no equivalent in R for a SAS macro include.  The R `source()` function
executes an external code file.  But it does not "include" or "insert" the
code into the calling program.  Therefore, the macro include from the 
**macro** package brings a useful feature to R.

A macro include from the **macro** package looks like this:
```{r eval=FALSE, echo=TRUE}
#%include 'c:/myfolder/myprogram.R'

```
Upon execution by `msource()`, the contents of "myprogram.R" will be extracted
from the file and copied into the calling program as text.  The calling program
will then be scanned for macro commands that may have existed in "myprogram.R".
The result will be a fully integrated program with all macro commands resolved.

# Next Steps

Here are the things to look at next:

- Example 1
- Example 2
- Disclaimer
