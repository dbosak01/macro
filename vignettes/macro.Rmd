---
title: "macro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{macro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Macro Concept

A macro language is like a meta-language for code.  The meta-language runs first,
generates the regular code, and then the regular code is executed to produce 
some sort of output.

The SASÂ® macro language is commonly used in SAS programs. The R **macro** package 
was inspired by SAS.

# An R Macro Language

Clearly, a macro language for R will not be the same as the SAS macro language.
The SAS macro language is built into the SAS execution environment.  The SAS
pre-processor is run automatically, and the macro syntax is understood by the 
SAS syntax checker.

With R, none of the above applies.  R does not have a built-in macro language, 
does not have a built-in pre-processor, and the R syntax checker will not 
expect any sort of macro language syntax.

Therefore, to build a macro-like functionality in R, we must get a little creative.

# Macro Statements

The first thing to note is that macro statements in the **macro** package are 
written as code comments.  The comments ensure that the R syntax checker will not
generate an error when reading the macro functions. 

In SAS, macro functions are
prefixed with a percent sign (%).  In R, macro statements are therefore prefixed
with a comment symbol (#) and a percent sign (%).  A simple macro assignment
looks like this:

```{r eval=FALSE, echo=TRUE}
#% Assign the macro variable "x"
#%let x = 1
```
A simple macro conditional looks like this:

```{r eval=FALSE, echo=TRUE}
#%if (x. == 1)
  print("x is one!")
#%else
  print("x is something else!")
#%end

```

Note that the above R macro syntax is not identical to the SAS syntax. The syntax
is a blend of SAS and R syntax, all inside a macro comment.

# The msource() function

In the **macro** package, pre-processing of the macro code is accomplished by a special function:
msource().  

The msource() function is similar to the "source()" function in R.
The msource() function will execute your code, just like the "source()" function.
First, however, it will execute the **macro** pre-processor.  

The steps can be summarized as follows:

Step 1: Pre-process the code and resolve all macro language syntax.  
Step 2: Generate a new code file with the resolved code.
Step 3: Execute the resolved code with the "source()" function.

Notice that the above steps map directly to the way the SAS
macro processor works.

In addition, the R macro language is a text-replacement language, just like SAS.  Macro
variables are swapped out with real values as text replacements.  Macro conditions
are evaluated, and only the code in the TRUE macro conditions is executed. 

All of the above is handled by the msource() function.  `msource()` is in fact the 
only user-facing function in the **macro** package.

## Available Functionality

The **macro** package supports the following functionality:

1. Macro Comments: Like regular R comments, but are not emitted to the output file.
2. Macro Variables:  Allow you to assign a value to a macro variable, and use
the macro variable as a text replacement token.
3. Macro Conditionals: If-Then-Else logic that allows you to conditionally 
execute a chunk of code.
4. System Function: The system function allows you to execute R functions
and operators as part of a macro statement.

### Macro Comments


### Macro Variables

Above we saw a simple macro variable assignment. Macro variables are defined with
the keyword `#%let` and then the variable name and value.  

Here are a few macro variable assignments for different data types:

```{r eval=FALSE, echo=TRUE}
#% Assign integer value 
#%let x = 1

#% Assign double value
#%let x = 1.2

#% Assign character value
#%let x = "Hello World!"

#% Assign date value
#%let x = as.Date("2025-07-15")

#% Assign vector
#%let x = c(1, 2, 3, 4, 5)

#% Assign calculated value
#%let x = 2 + 2

#% Assign using another macro variable
#%let y = x.

#% Calculate using another macro variable
#%let y = x. + 1
```
Once a macro variable is assigned, it can be used as a text replacement token
anywhere in your program.  

For example, we can use some of the above macro assignments like this:




### Simple Macro Conditionals

Macro conditionals allows you to conditionally execute a chunk of code.  If
a macro condition is TRUE, the code inside that condition will be output
to the generated code file and executed.  Code inside macro conditions that are 
FALSE will not be output to the generated code file.  In other words, 
only the code that is desired will be output to the generated code file.
This feature makes the code file more compact and easy to read.

Here are some examples of simple macro conditions:
```{r eval=FALSE, echo=TRUE}
#% Assign integer value 
#%let x = 1

#%if (x. == 1)
  # X is one
  print("Inside the first condition")
#%elseif (x. == 2)
  # X is two
  print("Inside the second condition")
#%else 
  # X is something else
  print("Inside the else.")
#%end

```
When executed with `msource()`, the above code will generate the result 
`"Inside the first condition"`.  If you pass a file name to the `file_out`
parameter of the `msource()` function, a code file will be generated.  That
code fill will contain the following content:
```
  # X is one
  print("Inside the first condition")

```
Notice that all spacing and comments from inside the condition are preserved.
Also notice that all macro code and code from inside other conditions has 
been removed.  This feature allows you to generate efficient and readable 
code files with minimal effort.

### Nested Macro Conditionals

Note that you can also nest macro conditionals.  Here is an 
example that illustrates such conditionals:

```{r eval=FALSE, echo=TRUE}
#% Assign integers
#%let x = 1
#%let y = 2

#%if (x. == 1)

  #%if (y. == 1)

    print("X is one and Y is 1")

  #%else

    print("X is one and Y is y.")

  #%end

#%elseif (x. == 2)

    #%if (y. == 1)

    print("X is two and Y is 1")

    #%else

    print("X is two and Y is y.")

    #%end

#%else

  #%if (y. == 1)

    print("X is x. and Y is 1")

  #%else

    print("X is x. and Y is y.")

  #%end

#%end

```
The result of the above code will be "X is one and Y is 2".  The 


### System Function


### Macro Include



## Disclaimer

The **macro** package should not be used as a substitute for normal R variables and 
conditions.  In general, the R macro facility should be used 
sparingly.  There are only a few scenarios when the R macro facility is advantageous.

The primary scenario **macro** package was written for is code generation. In this
scenario, macro capability allows you to easily produce a resolved code file
that can be saved and run independently.  It is easier to produce such a resolved
program using a macro language than alternative methods.

The other scenario the **macro** package may be useful is for translation of
programs from SAS.  The R macro syntax can be translated quite directly from 
SAS, without having to rethink the logic.

Outside of these two scenarios, using R macros must be carefully considered, 
as they can introduce unnecessary complexity and make your code harder to debug.
